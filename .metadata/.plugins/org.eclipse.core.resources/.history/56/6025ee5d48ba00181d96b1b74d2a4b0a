//@Author: Jacob Duchen
//I am not super happy that there is so much logic in our controller methods and that all of the services are pulled in here. I think it would be better to keep the services talking to eachother. 

package com.jacob.controller;

import java.util.List;

import javax.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.jacob.jdbcService.BlogService;
import com.jacob.jdbcService.CommentService;
import com.jacob.jdbcService.UpvoteService;
import com.jacob.jdbcService.UserService;
import com.jacob.model.Blog;
import com.jacob.model.User;

@Controller
@RequestMapping()
public class BlogController {

	 @Autowired
	 private BlogService blogService;

	 @Autowired
	 private UserService userService;

	 @Autowired
	 private UpvoteService upvoteService;

	 @Autowired
	 private CommentService commentService;

	 //this method provides user the view to write a blog
	 @RequestMapping(value= {"create"}, method=RequestMethod.GET)
	 public ModelAndView createBlog(@Valid User user) {

	  ModelAndView model = new ModelAndView();
	  model.addObject("tempBlog", new Blog());
	  model.setViewName("create");

	  return model;
	 }

	 //this method checks if current user.id is the author_id of the blog user is attempting to edit. If user is the author of blog, they can edit, we return true; otherwise we return false. 
	 public boolean checkIfUserShouldBeAbleToUpdate(User user, Blog blog) {
		 if (blog.getAuthor_id() == user.getId()) {
			  return true;
		  } else {
			  return false;
		  }
	 }

	 //here is our delete blog action. We really dont delete the blog here. But we have some logic to allow user to get to delete page, or provide them error page. We really should prevent not-correct user from even seeing the delete and edit pages.
	 @RequestMapping(value = "/delete/{id}", method=RequestMethod.GET)
	 public ModelAndView deleteBlog(@PathVariable(value = "id", required =false) int id) {
		  //this variable will be used to get current user Authentication(where we can get there user id from) from spring security 
		 Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		 
		 //getting user object from spring security Authentication object 
		  User tempUser = userService.findUserByEmail(auth.getName());
		  
		  ModelAndView model = new ModelAndView();
		  
		  //get the blog that user wants to delete!
		  Blog tempBlog =  blogService.getBlog(id);
		  
		  //get author of that blog
		  User tempBlogAuthor = userService.findUserById(tempBlog.getAuthor_id());

		  //lets use that user.id = blog.author.id method we mentioned previously 
		  boolean access = checkIfUserShouldBeAbleToUpdate(tempUser, tempBlog);
		  if (!access) {
			  System.out.println("Wrong user!!!!");
			  //we return error page to user trying to delete blog they shouldnt have rights too
			  model.setViewName("access_denied");
			  return model;
		  }
		  
		  //get our delete jsp which has the action attached to it where user can actually delete a blog
		  model.setViewName("delete");
		  
		  //get amount of comments to display to user 
		  model.addObject("listOfCommentsSize", commentService.getCommentCountForABlog(id));
		  
		  //get amount of upvotes to display to user 
		  model.addObject("tempUpvoteCount", upvoteService.countUpvotes(id));
		  
		  //get blogObject to pass to user. We really are passing duplicate data here that can be refactored in the future. 
		  model.addObject("blogObject", tempBlog);
		  
		  //id of blog in question 
		  model.addObject("id", id);
		  
		  //displaying strings of author names on the page
		  model.addObject("authorName", tempBlogAuthor.getFirstname() + " " + tempBlogAuthor.getLastname());
		  
		  //displaying string of email for the page
		  model.addObject("authorEmail", tempBlogAuthor.getEmail());
		  
		  //displaying string of title of blog for the page
		  model.addObject("title", tempBlog.getTitle());
		  
		  //displaying string of content of blog for the page
		  model.addObject("content", tempBlog.getContent());

		  //returning the modelView which holds all this information, which the delete.jsp will consume
		  return model;
	 }

	 //this view blog has a lot of logic, and repeated data, that needs to be refactored
	 @RequestMapping(value = "/blog/{id}", method=RequestMethod.GET)
	 public ModelAndView viewBlog(@PathVariable(value = "id",  required =false) int id) {
		  ModelAndView model = new ModelAndView();
		  
		  //getting blog object from path variable int id so we can pull out all relevant information to display on the jsp
		  Blog tempBlog =  blogService.getBlog(id);
		  
		  //getting all of our comments 
		  List<String> blogComments = commentService.getContentOfCommentsForABlog(tempBlog.getId());
		  
		  //getting author name from blog.author_id to display on page 
		 User author = userService.findUserById(tempBlog.getAuthor_id());

		 Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		  User tempUser = userService.findUserByEmail(auth.getName());
		  boolean access = checkIfUserShouldBeAbleToUpdate(tempUser, tempBlog);

		  if(blogComments.size() == 0) {
			  model.addObject("commentListEmpty", "Sorry there are no comments as of now :(");
			  model.addObject("listOfCommentsSize", blogComments.size());

		  } else {
			  List<String> commentsAuthors = commentService.getAuthorsOfCommentsForABlog(id);
			  model.addObject("ourCommentAuthors", commentsAuthors);
			  model.addObject("comments", blogComments);
			  model.addObject("listOfCommentsSize", blogComments.size());
		  }

		  model.addObject("currentUserId", tempUser.getId());
		  model.addObject("currentUserEmail", tempUser.getEmail());
		  model.addObject("blogObject", tempBlog);
		  model.addObject("crudRights", access);
		  model.addObject("blogId", tempBlog.getId());

		  if ((author.getFirstname() + author.getLastname()).length() == 0) {
			  model.addObject("authorName", "Anonymous");
		  } else {
			  model.addObject("authorName", author.getFirstname() + " " + author.getLastname());
		  }
		  model.addObject("authorName", author.getFirstname() + " " + author.getLastname());
		  model.addObject("authorEmail", author.getEmail());
		  model.addObject("title", tempBlog.getTitle());
		  model.addObject("content", tempBlog.getContent());
		  model.addObject("tempUpvoteCount", upvoteService.countUpvotes(id));

		  model.setViewName("blog");

		  return model;
	 }

	 @RequestMapping(value = "/edit/{id}", method=RequestMethod.GET)
	 public ModelAndView editBlog(@PathVariable(value = "id", required =false) int id) {

		 Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		  User tempAuthor = userService.findUserByEmail(auth.getName());
		  ModelAndView model = new ModelAndView();
		  Blog tempBlog =  blogService.getBlog(id);

		  boolean access = checkIfUserShouldBeAbleToUpdate(tempAuthor, tempBlog);

		  if (!access) {
			  System.out.println("Not your blog to edit!!!!!");
			  model.setViewName("access_denied");
			  return model;
		  }

		  model.setViewName("edit");
		  model.addObject("blogId", tempBlog.getId());
		  model.addObject("authorName", tempAuthor.getFirstname() + " " + tempAuthor.getLastname());
		  model.addObject("title", tempBlog.getTitle());
		  model.addObject("content", tempBlog.getContent());
		  model.addObject("tempUpvoteCount", upvoteService.countUpvotes(id));


		  return model;

	 }

	 @RequestMapping(value="saveBlog", method=RequestMethod.POST)
	 public ModelAndView save(@ModelAttribute("tempBlog") Blog temp) {

	  Authentication auth = SecurityContextHolder.getContext().getAuthentication();
	  User tempAuthor = userService.findUserByEmail(auth.getName());
	  int tempAuthorId = tempAuthor.getId();
	  temp.setAuthor_id(tempAuthorId);
	  blogService.saveBlog(temp);

	  return new ModelAndView("redirect:/home");
	 }


	 @RequestMapping(value = "/deleteTheBlog", method=RequestMethod.POST)
	 public ModelAndView deleteTheBlog(@ModelAttribute("id") int id) {

		 blogService.deleteBlog(id);

	  return new ModelAndView("redirect:/home");
	 }

	 @RequestMapping(value="updateBlog", method=RequestMethod.POST)
	 public ModelAndView update(@ModelAttribute("tempBlog") Blog temp) {
		  System.out.println("blogController updateBlog Update method called");
		  blogService.updateBlog(temp);
		  return new ModelAndView("redirect:/home");
	 }




}
